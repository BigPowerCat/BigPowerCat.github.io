<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="&lt;p&gt;Java修饰符，主要是分为一下两类：&lt;/p&gt;
&lt;p&gt;1、访问修饰符&lt;/p&gt;
&lt;p&gt;2、非访问修饰符&lt;/p&gt;
&lt;h2 id=&#34;访问控制修饰符&#34;&gt;&lt;a href=&#34;#访问控制修饰符&#34; class=&#34;headerlink&#34; title=&#34;访问控制修饰符&#34;&gt;&lt;/a&gt;访问控制修饰符&lt;/h2&gt;&lt;p&gt;Java中，可以使用访问控制符来保护对类、变量、方法和工造方法的访问&lt;/p&gt;
&lt;p&gt;Java下一共有四种：">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=yes">
  <title>Java修饰符 | powercat</title>

  <link rel="stylesheet" id="chosen-theme" href="https://rawgit.com/fiatjaf/classless/master/themes/plain/theme.css">
  <script>
let link = document.getElementById('chosen-theme')
let widget = document.createElement('div')
widget.style.position = 'absolute'
widget.style.right = '5px'
widget.style.top = '2px'
widget.style.background = 'beige'
widget.style.color = '#444'
widget.style.zIndex = 99
widget.style.padding = '4px 8px'
widget.innerHTML = `
<label>
  <p>No theme was set on <code>theme_config</code>.<br>
     Choose a theme from the list to experiment with it:</p>
  <select></select>
</label>
`
fetch('https://api.github.com/repos/fiatjaf/classless/contents/themes')
  .then(r => r.json())
  .then(files => {
    document.body.appendChild(widget)
    let select = document.querySelector('select')
    files
      .filter(f => f.type === 'dir')
      .forEach(f => {
        let option = document.createElement('option')
        option.value = f.name
        option.innerHTML = f.name
        select.appendChild(option)
      })
    let options = Array.from(select.querySelectorAll('option'))
    let chosen = options[parseInt(Math.random() * options.length)]
    chosen.selected = true
    link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen.value}`)
    select.addEventListener('change', e => {
      let chosen = e.target.value
      link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen}`)
    })
  })
  .catch(console.log)
  </script>

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <header role="banner">
      <a href="/">
        
          <img src="https://picsum.photos/640/480">
        
      </a>  
    <h1>
      <a href="/">powercat</a>
    </h1>
    <aside>
      <p></p>
    </aside>
  </header>
  
  <main>
    <article>
  <header>
  
  <h1><a href="http://example.com/2022/07/23/java3/">Java修饰符</a></h1>
  <aside>
    
    <time datetime="222022-07-23">
      July 23rd 2022
    </time>
    
    <ul>
    
      <li><a href="/tags/note/">note</a></li>
    
    </ul>
  </aside>
</header>

  <div><p>Java修饰符，主要是分为一下两类：</p>
<p>1、访问修饰符</p>
<p>2、非访问修饰符</p>
<h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>Java中，可以使用访问控制符来保护对类、变量、方法和工造方法的访问</p>
<p>Java下一共有四种：</p>
<p>1、default：默认的修饰符，在同一包内可见，不适用任何修饰符。对象、接口、变量、方法。</p>
<p>2、private：在同一类内可见。使用对象：变量、方法。 （不能修饰类</p>
<p>3、public：对所有类可见。对象、接口、变量、方法。</p>
<p>4、protected：对同意包内的类和所有子类可见。使用对象：变量、方法。</p>
<p>访问控制|修饰符|当前类|同一包内|子孙类(同一包)|子孙类(不同包)|其他包|<br><br /><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220723191854-25m0tel.png" alt="image.png"></p>
<h3 id="默认访问修饰符-不适用任何关键字"><a href="#默认访问修饰符-不适用任何关键字" class="headerlink" title="默认访问修饰符-不适用任何关键字"></a>默认访问修饰符-不适用任何关键字</h3><p>使用默认访问修饰符声明的变量方法，对于同一个包内的类是可是的。接口里的变量都隐式声明为<code>public static final</code>,而接口里的方法默认情况下访问权限为<strong>public</strong>。</p>
<p>如下例所示，变量和方法的声明可以不使用任何修饰符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;1.5.1&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h3><p>私有访问修饰符是最严格的访问级别，所以被声明<strong>private</strong> 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为  <strong>private</strong> 。</p>
<h3 id="公有访问修饰符-public"><a href="#公有访问修饰符-public" class="headerlink" title="公有访问修饰符-public"></a>公有访问修饰符-public</h3><p>类似于全局变量似的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arguments)</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。</p>
<h3 id="受保护的访问修饰符-protected"><a href="#受保护的访问修饰符-protected" class="headerlink" title="受保护的访问修饰符-protected"></a>受保护的访问修饰符-protected</h3><p>protected 需要从以下两个点来分析说明：</p>
<ul>
<li><strong>子类与基类在同一包中</strong> ：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li><strong>子类与基类不在同一包中</strong> ：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li>
</ul>
<p>protected 可以修饰数据成员，构造方法，方法成员， <strong>不能修饰类（内部类除外）</strong> 。</p>
<p>接口及接口的成员变量和成员方法不能声明为 protected。</p>
<p>子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<p>下面的父类使用了 protected 访问修饰符，子类重写了父类的 openSpeaker() 方法。</p>
<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被子类继承。</li>
</ul>
<h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><h3 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h3><ul>
<li><strong>静态变量：</strong><br>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</li>
<li><strong>静态方法：</strong><br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li>
</ul>
<p>对类变量和方法的访问可以直接使用 <strong>classname.variablename</strong> 和 <strong>classname.methodname</strong> 的方式访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCounter</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numInstances</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> numInstances;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      numInstances++;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   InstanceCounter() &#123;</span><br><span class="line">      InstanceCounter.addInstance();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arguments)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Starting with &quot;</span> +</span><br><span class="line">      InstanceCounter.getCount() + <span class="string">&quot; instances&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; ++i)&#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">InstanceCounter</span>();</span><br><span class="line">          &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Created &quot;</span> +</span><br><span class="line">      InstanceCounter.getCount() + <span class="string">&quot; instances&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 下面是声明常量的实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BOXWIDTH</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TITLE</span> <span class="operator">=</span> <span class="string">&quot;Manager&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeValue</span><span class="params">()</span>&#123;</span><br><span class="line">     value = <span class="number">12</span>; <span class="comment">//将输出一个错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h4><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。</p>
<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p>如下所示，使用 final 修饰符声明方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">changeName</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h4><p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="comment">// 类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<p>抽象类可以包含抽象方法和非抽象方法。</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</p>
<p>抽象方法不能被声明成 final 和 static。</p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<p>抽象方法的声明以分号结尾，例如： <strong>public abstract sample();</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">     <span class="comment">//实现抽象方法</span></span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">          .........</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<h3 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p>
<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<h3 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个 volatile 对象引用可能是 null。</p>
</div>
</article>

  </main>
  <aside>
    <p>This is an `aside`, a useful place to put information of any kind: metadata about the site author (with or without pictures), brief information about the purposes of the site, a static collection of external links or anything else.</p>
<p>For some Classless themes pictures and data about the author may suit better in the `cover` and `description` site attributes (see `config.toml`), but most of the times that kind of information will fit here better.</p>

  </aside>
  <footer role="contentinfo">
    <p>A default site footer. If you don't know what to place here maybe you should just write your name plus the current year?</p>
<p>If you want to have a sitemap, a contact form or other complex stuff, most Classless themes will also handle it nicely. Or you can take a look at the <code>aside.html</code> partial.</p>

  </footer>
</body>
