<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="&lt;h3 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直没学过这个，在学习glibc2.34下的emma利用中有一个相关的节点，利用largebin attack将fs：0x30中的guard修改。其实我并不知道这个东西是啥只是看这wjh👴的文章一点一点的去复现。所以来了解一下，emmmm，理由十分牵强。这篇">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=yes">
  <title>Glibc TLS结合源码的分析 | powercat</title>

  <link rel="stylesheet" id="chosen-theme" href="https://rawgit.com/fiatjaf/classless/master/themes/plain/theme.css">
  <script>
let link = document.getElementById('chosen-theme')
let widget = document.createElement('div')
widget.style.position = 'absolute'
widget.style.right = '5px'
widget.style.top = '2px'
widget.style.background = 'beige'
widget.style.color = '#444'
widget.style.zIndex = 99
widget.style.padding = '4px 8px'
widget.innerHTML = `
<label>
  <p>No theme was set on <code>theme_config</code>.<br>
     Choose a theme from the list to experiment with it:</p>
  <select></select>
</label>
`
fetch('https://api.github.com/repos/fiatjaf/classless/contents/themes')
  .then(r => r.json())
  .then(files => {
    document.body.appendChild(widget)
    let select = document.querySelector('select')
    files
      .filter(f => f.type === 'dir')
      .forEach(f => {
        let option = document.createElement('option')
        option.value = f.name
        option.innerHTML = f.name
        select.appendChild(option)
      })
    let options = Array.from(select.querySelectorAll('option'))
    let chosen = options[parseInt(Math.random() * options.length)]
    chosen.selected = true
    link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen.value}`)
    select.addEventListener('change', e => {
      let chosen = e.target.value
      link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen}`)
    })
  })
  .catch(console.log)
  </script>

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <header role="banner">
      <a href="/">
        
          <img src="https://picsum.photos/640/480">
        
      </a>  
    <h1>
      <a href="/">powercat</a>
    </h1>
    <aside>
      <p></p>
    </aside>
  </header>
  
  <main>
    <article>
  <header>
  
  <h1><a href="http://example.com/2022/04/16/tls/">Glibc TLS结合源码的分析</a></h1>
  <aside>
    
    <time datetime="222022-04-16">
      April 16th 2022
    </time>
    
    <ul>
    
      <li><a href="/tags/study/">study</a></li>
    
    </ul>
  </aside>
</header>

  <div><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直没学过这个，在学习glibc2.34下的emma利用中有一个相关的节点，利用largebin attack将fs：0x30中的guard修改。其实我并不知道这个东西是啥只是看这wjh👴的文章一点一点的去复现。所以来了解一下，emmmm，理由十分牵强。这篇只是一个概述，之后会对TLS安全进行一个更详细的分析，</p>
<h3 id="TLS的简单介绍"><a href="#TLS的简单介绍" class="headerlink" title="TLS的简单介绍"></a>TLS的简单介绍</h3><p>TLS的全称为Thread Local Storage，是一种线程独占的本地空间，在TLS之前只能使用pthread_getspecific以及pthread_setspecific函数来存储线程的储存，这种方法效率不高，在TLS出现之后我i们就可以用__thread关键字来告知编译器某一个变量应当被放在TLS，而且只需要几条汇编指令就可以访问到变量。</p>
<h4 id="网上piao一个师傅的实例"><a href="#网上piao一个师傅的实例" class="headerlink" title="网上piao一个师傅的实例"></a>网上piao一个师傅的实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">static __thread <span class="built_in">int</span> a = <span class="number">12345</span>; // <span class="number">0x3039</span></span><br><span class="line">__thread unsigned long long b = <span class="number">56789</span>; // <span class="number">0xddd5</span></span><br><span class="line">__thread <span class="built_in">int</span> c;</span><br><span class="line"></span><br><span class="line">void <span class="keyword">try</span>(void *tmp) &#123;</span><br><span class="line">    printf(<span class="string">&quot;try: a = %lx, b = %llx, c = %s\n&quot;</span>, a, b, &amp;c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void) &#123;</span><br><span class="line">    a = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    b = <span class="number">0xbadcaffe</span>;</span><br><span class="line">    c = <span class="number">0x61616161</span>;</span><br><span class="line">    printf(<span class="string">&quot;main thread: a = %lx, b = %llx, c = %s\n&quot;</span>, a, b, &amp;c);</span><br><span class="line">    pthread_t pid;</span><br><span class="line">    pthread_create(&amp;pid, NULL, <span class="keyword">try</span>, NULL);</span><br><span class="line">    pthread_join(pid, NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用gcc tls.c -pthread -g -o tls进行编译运行代码</p>
<p>我们发现运行之后的结果是这样的</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220522193854-5tvj5a7.png" alt="image.png"></p>
<p>这就体现了TLS的强大之处了，__thread解释之后虽然abc是全局变量，并且在main函数当中进行了数值的覆盖，但是在thread中还是原来的数值，所以我们猜测thread是利用另外的一套存储数据的结构来实现的这种线程上的独立。我们在用gdb调试一下这个程序</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220522200517-4buzrbz.png" alt="image.png"></p>
<p>我们vmmap之后发现是程序给tls留出了一个另外的存储数据段，查看数据section的时候程序中多出了两个数据段.todata、.tbss这两个数据段中存储的是thread中的数据就是我们声明的全局变量TLS中的abc。我们继续运行程序看看。</p>
<p>我们发现在try中的printf中传参使用的地址是fs的</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220522201233-uef546g.png" alt="image.png"></p>
<h4 id="Glibc的TLS实现"><a href="#Glibc的TLS实现" class="headerlink" title="Glibc的TLS实现"></a>Glibc的TLS实现</h4><p>去巴拉巴拉源码吧，</p>
<h5 id="非主线程情形"><a href="#非主线程情形" class="headerlink" title="非主线程情形"></a>非主线程情形</h5><h6 id="TCB结构体以及static-TLS的空间分配"><a href="#TCB结构体以及static-TLS的空间分配" class="headerlink" title="TCB结构体以及static TLS的空间分配"></a>TCB结构体以及static TLS的空间分配</h6><p>在函数pthread_create 中存在下面一条调用链：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_create -&gt; ALLOC_STACK</span><br></pre></td></tr></table></figure>

<p>ALLOCATE_STACK函数通过下面的操作来为新线程分配栈：</p>
<p>我们可以发现，新栈的底部被分配了一个容纳pd结构体的空间，该结构体的类型为struct pthread，我们称其为一个thread descriptor，该结构体的第一个域被称为tchhead_t类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE, MAP_PRIVATE  MAP_ANONYMOUS  MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 使用mmap函数来分配一块匿名映射来作为我们的新栈 */</span></span><br><span class="line"><span class="comment">/* !!! omitted some code !!! */</span></span><br><span class="line"><span class="comment">/* 将thread descriptor（pd指针指向的结构体）放到新栈的栈底 */</span></span><br><span class="line">pd = (<span class="keyword">struct</span> pthread *) ((((<span class="type">uintptr_t</span>) mem + size)</span><br><span class="line">            - TLS_TCB_SIZE)</span><br><span class="line">            &amp; ~__static_tls_align_m1);</span><br><span class="line"><span class="comment">/* 进行这一步操作后内存布局如下：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *                                  TLS_TCB_SIZE</span></span><br><span class="line"><span class="comment"> *                                        ^</span></span><br><span class="line"><span class="comment"> *                            +-----------+----------+</span></span><br><span class="line"><span class="comment"> *                                                </span></span><br><span class="line"><span class="comment"> * ---------------------+----------------------------+</span></span><br><span class="line"><span class="comment"> *                                               </span></span><br><span class="line"><span class="comment"> *                       pad                     </span></span><br><span class="line"><span class="comment"> *                                               </span></span><br><span class="line"><span class="comment"> * ---------------------+----------------------------+</span></span><br><span class="line"><span class="comment"> *                            ^                      ^</span></span><br><span class="line"><span class="comment"> *                            +                      +</span></span><br><span class="line"><span class="comment"> *                           pd                mmap area end</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* !!! omitted some code !!! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate the DTV for this thread.  */</span></span><br><span class="line"><span class="keyword">if</span> (_dl_allocate_tls (TLS_TPADJ (pd)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Something went wrong.  */</span></span><br><span class="line">        assert (errno == ENOMEM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Free the stack memory we just allocated.  */</span></span><br><span class="line">        (<span class="type">void</span>) __munmap (mem, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>tchhead_t</code>类型，其定义如下：</p>
<p>这就是我们之前提到的TCB结构体的具体实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">               thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>

<h6 id="父线程TCB的继承"><a href="#父线程TCB的继承" class="headerlink" title="父线程TCB的继承"></a>父线程TCB的继承</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Copy the stack guard canary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREAD_COPY_STACK_GUARD</span></span><br><span class="line">  THREAD_COPY_STACK_GUARD (pd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Copy the pointer guard value.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> THREAD_COPY_POINTER_GUARD</span></span><br><span class="line">  THREAD_COPY_POINTER_GUARD (pd);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在栈分配之后，我们在pthread函数中看到了上面的代码。将宏展开之后可以看到下面的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read member of the thread descriptor directly.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> THREAD_GETMEM(descr, member) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (descr-&gt;member) __value;                        \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (sizeof (__value) == 1)                           \</span></span><br><span class="line"><span class="meta">       asm volatile (<span class="string">&quot;movb %%fs:%P2,%b0&quot;</span>                      \</span></span><br><span class="line"><span class="meta">             : <span class="string">&quot;=q&quot;</span> (__value)                         \</span></span><br><span class="line"><span class="meta">             : <span class="string">&quot;0&quot;</span> (0), <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));     \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span> <span class="keyword">if</span> (sizeof (__value) == 4)                          \</span></span><br><span class="line"><span class="meta">       asm volatile (<span class="string">&quot;movl %%fs:%P1,%0&quot;</span>                       \</span></span><br><span class="line"><span class="meta">             : <span class="string">&quot;=r&quot;</span> (__value)                         \</span></span><br><span class="line"><span class="meta">             : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));          \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span>                                     \</span></span><br><span class="line"><span class="meta">       &#123;                                      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (sizeof (__value) != 8)                       \</span></span><br><span class="line"><span class="meta">       <span class="comment">/* There should not be any value with a size other than 1,         \</span></span></span><br><span class="line"><span class="comment"><span class="meta">          4 or 8.  */</span>                             \</span></span><br><span class="line"><span class="meta">       abort ();                                  \</span></span><br><span class="line"><span class="meta">                                          \</span></span><br><span class="line"><span class="meta">     asm volatile (<span class="string">&quot;movq %%fs:%P1,%q0&quot;</span>                    \</span></span><br><span class="line"><span class="meta">               : <span class="string">&quot;=r&quot;</span> (__value)                       \</span></span><br><span class="line"><span class="meta">               : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, member)));        \</span></span><br><span class="line"><span class="meta">       &#125;                                      \</span></span><br><span class="line"><span class="meta">     __value; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> THREAD_COPY_STACK_GUARD(descr) \</span></span><br><span class="line"><span class="meta">    ((descr)-&gt;header.stack_guard                          \</span></span><br><span class="line"><span class="meta">     = THREAD_GETMEM (THREAD_SELF, header.stack_guard))</span></span><br></pre></td></tr></table></figure>

<p>不难看出，这一段的作用是将父进程的canary复制到当前进程的TCB结构体中。事实上，在fs寄存器尚未被改变之前，其中存放着父进程的TCB地址，我们可以使用THREAD_SELF宏来获取父线程的TCB指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> THREAD_SELF \</span></span><br><span class="line"><span class="meta">  (&#123; struct pthread *__self;                              \</span></span><br><span class="line"><span class="meta">     asm (<span class="string">&quot;mov %%fs:%c1,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (__self)                   \</span></span><br><span class="line"><span class="meta">      : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, header.self)));            \</span></span><br><span class="line"><span class="meta">     __self;&#125;)</span></span><br></pre></td></tr></table></figure>

<h6 id="dtv实现简介"><a href="#dtv实现简介" class="headerlink" title="dtv实现简介"></a>dtv实现简介</h6><p>我们沿着调用链找到了dtv数组以及TLS Blocks的具体实现。首先查看dtv_t类型的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *val;                    <span class="comment">/* Pointer to data, or TLS_DTV_UNALLOCATED.  */</span></span><br><span class="line">  <span class="type">void</span> *to_free;                <span class="comment">/* Unaligned pointer, for deallocation.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type for the dtv.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">dtv</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">size_t</span> counter;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtv_pointer</span> <span class="title">pointer</span>;</span></span><br><span class="line">&#125; <span class="type">dtv_t</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到该类型是一个联合，其值有可能是一个counter，该counter在dtv[-1]以及dtv[0]这个成员使用，标志dtv数组中的入口个数；其值也有可能是一个dtv_pointer结构体，其中的成员指向一个TLS Block。</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220523092123-oo8ium1.png" alt="image.png"></p>
<p>需要注意的是<code>dtv</code>使用<code>module ID</code>作为索引，程序装载的每一个<code>module</code>都会有一个<code>module ID</code>，这个值存在于这个<code>module</code>对应的<code>link_map</code>结构体中，该结构体中的相关成员如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* 与TLS有关的内容  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TLS segment的起始地址，TLS segment由两部分组成，分别是tdata和tbss，存放初始化和未初始化的全局变量</span></span><br><span class="line"><span class="comment">     * 该segment在module被装载的时候映射的内存中，作为每一个线程初始化TLS Blocks时的模版 */</span></span><br><span class="line">    <span class="type">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* TLS segment在文件中的大小（仅.tdata的大小）  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* TLS segment在内存中的大小（.data加上.tbss的大小）*/</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* TLS Block的对齐标准  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* 符合对齐要求的第一个字节的偏移  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NO_TLS_OFFSET  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">error</span> <span class="string">&quot;FORCED_DYNAMIC_TLS_OFFSET is not defined&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="comment">/* 对于程序加载时就装载了的模块，该变量标示本模块对应的TLS Block在static TLS中的偏移.  */</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* 本模块在dtv数组中的索引  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_modid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 由该动态链接库构造的tls变量的数量  */</span></span><br><span class="line">    <span class="type">size_t</span> l_tls_dtor_count;</span><br></pre></td></tr></table></figure>

<h6 id="dtv数组的空间分配"><a href="#dtv数组的空间分配" class="headerlink" title="dtv数组的空间分配"></a>dtv数组的空间分配</h6><p>可以看到如下调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_create -&gt; ALLOC_STACK -&gt; _dl_allocate_tls -&gt; allocate_dtv -&gt;  _dl_allocate_tls_init</span><br></pre></td></tr></table></figure>

<p>程序在<code>allocate_dtv</code>函数中为dtv数组分配空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">allocate_dtv</span> <span class="params">(<span class="type">void</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">size_t</span> dtv_length;</span><br><span class="line"></span><br><span class="line">  dtv_length = GL(dl_tls_max_dtv_idx) + DTV_SURPLUS;</span><br><span class="line">  dtv = <span class="built_in">calloc</span> (dtv_length + <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="type">dtv_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (dtv != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* dtv长度的初始值 */</span></span><br><span class="line">      dtv[<span class="number">0</span>].counter = dtv_length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* dtv的余下部分被初始化为0，来表示这里什么也没有 */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 将dtv加入到线程描述符中 */</span></span><br><span class="line">      INSTALL_DTV (result, dtv);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>申请了一块区域赋值给dtv，然后利用一些宏进行一波操作，将宏展开之后是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">tcbhead_t</span> *) (result))-&gt;dtv = (dtv) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>到这里TCB中指向的dtv数组的空间已经被成功分配。</p>
<h6 id="static-TLS以及fs的初始化"><a href="#static-TLS以及fs的初始化" class="headerlink" title="static TLS以及fs的初始化"></a>static TLS以及fs的初始化</h6><p> 下面我们来看<code>_dl_allocate_tls_init</code>函数中进行的初始化工作： 从宏观上来说，该函数进行了一次对link_map的遍历，并且对于link_map链表中的每一个节点（对应一个模块）都进行了如下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* result指针指向TCB结构体， map为link map的一个节点 */</span></span><br><span class="line">dest = (<span class="type">char</span> *) result - <span class="built_in">map</span>-&gt;l_tls_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置DTV entry，一些平台在静态链接的程序中使用的简化版的__tls_get_addr需要这个值 */</span></span><br><span class="line">dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = dest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制初始镜像，并将bss段清零  */</span></span><br><span class="line"><span class="built_in">memset</span> (__mempcpy (dest, <span class="built_in">map</span>-&gt;l_tls_initimage,</span><br><span class="line">            <span class="built_in">map</span>-&gt;l_tls_initimage_size), <span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">                <span class="built_in">map</span>-&gt;l_tls_blocksize - <span class="built_in">map</span>-&gt;l_tls_initimage_size);</span><br></pre></td></tr></table></figure>

<p>对每一个module进行这一步操作后，（不考虑dlopen，dlfree）我们的TLS已经被初始化完成了。这时我们还留有最后一个疑问：谁设置了fs寄存器？ 我们知道，fs寄存器是用户态程序无法设置，我们只能通过系统调用进行设置。因此我们使用<code>strace -f ./tls</code>命令来跟踪程序执行中的系统调用，如我们所料，我们在clone系统调用中发现了如下参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(child_stack=<span class="number">0x7fa882eeffb0</span>, flags=CLONE_VMCLONE_FSCLONE_FILESCLONE_SIGHANDCLONE_THREADCLONE_SYSVSEMCLONE_SETTLSCLONE_PARENT_SETTIDCLONE_CHILD_CLEARTID, parent_tid=[<span class="number">37577</span>], tls=<span class="number">0x7fa882ef0700</span>, child_tidptr=<span class="number">0x7fa882ef09d0</span>) = <span class="number">37577</span></span><br></pre></td></tr></table></figure>

<p>进而查找glibc中<code>pthread_create</code>函数对clone的调用，我们找到如下调用链在TCB被设置之后完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_create -&gt; create_thread -&gt; clone syscall</span><br></pre></td></tr></table></figure>

<p>clone处的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">const</span> <span class="type">int</span> clone_flags = (CLONE_VM  CLONE_FS  CLONE_FILES  CLONE_SYSVSEM</span><br><span class="line">              CLONE_SIGHAND  CLONE_THREAD</span><br><span class="line">              CLONE_SETTLS  CLONE_PARENT_SETTID</span><br><span class="line">              CLONE_CHILD_CLEARTID</span><br><span class="line">              <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">TLS_DEFINE_INIT_TP (tp, pd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (ARCH_CLONE (&amp;start_thread, STACK_VARIABLES_ARGS,</span><br><span class="line">                  clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)</span><br><span class="line">          == <span class="number">-1</span>))</span><br><span class="line">  <span class="keyword">return</span> errno;</span><br></pre></td></tr></table></figure>

<p>有调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone -&gt; _do_fork -&gt; copy_process -&gt; copy_thread_tls -&gt; do_arch_prctl_64</span><br></pre></td></tr></table></figure>

<h3 id="TLS安全机制"><a href="#TLS安全机制" class="headerlink" title="TLS安全机制"></a>TLS安全机制</h3><h4 id="stack-canary"><a href="#stack-canary" class="headerlink" title="stack canary"></a>stack canary</h4><p>我们熟悉的canary机制就是源于这里，我们在做题的时候查看汇编会发现我们查看stack的时候是取用的fs:0x28中的内容。</p>
<h4 id="pointer-guard"><a href="#pointer-guard" class="headerlink" title="pointer guard"></a>pointer guard</h4><p>这种东西就是我学习TLS的目的，这是一个我们经常会忽略的一个保护机制，先看一下相关宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var)   asm (<span class="string">&quot;xor %%fs:%c2, %0\n&quot;</span>             \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;rol $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0&quot;</span>           \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=r&quot;</span> (var)                 \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;0&quot;</span> (var),                 \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,          \</span></span><br><span class="line"><span class="meta">                              pointer_guard)))</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) asm (<span class="string">&quot;ror $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0\n&quot;</span>         \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>               \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=r&quot;</span> (var)                 \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;0&quot;</span> (var),                 \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,          \</span></span><br><span class="line"><span class="meta">                              pointer_guard)))</span></span><br><span class="line"><span class="comment">// 64位情况下，LP_SIZE为0x10</span></span><br></pre></td></tr></table></figure>

<p>可以看到这两个宏利用<code>pointer_guard</code>分别对指针进行了加密和解密操作，加密由一次异或以及一次bitwise rotate组成。加密使用的key来自<code>fs:[offsetof(tcbhead_t, pointer_guard)]</code>。接下来我们将对加密和解密的脆弱性进行解析。 利用<code>pointer_guard</code>进行加密的过程可以表示为<code>rol(ptr ^ pointer_guard, 0x11, 64)</code>，解密的过程为<code>ror(enc, 0x11, 64) ^ pointer_guard</code>。那么假设现在我们知道了enc和ptr两个值，我们就可以通过这个算式来计算出<code>pointer_guard</code>(64位情况)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer_guard = ror (enc, <span class="number">0x11</span>, <span class="number">64</span>) ^ ptr </span><br></pre></td></tr></table></figure>

<p>同时假设我们获得了对<code>pointer_guard</code>的任意写，并且已知会调用一个函数指针<code>enc</code>，以及恶意地址<code>evil_ptr</code>，我们可以通过修改<code>pointer_guard</code>为<code>evil_guard</code>来将解密后的指针导向恶意地址，转换关系如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil_guard = ror (enc, <span class="number">0x11</span>, <span class="number">64</span>) ^ evil_ptr</span><br></pre></td></tr></table></figure>

<h3 id="TLS的相关攻击"><a href="#TLS的相关攻击" class="headerlink" title="TLS的相关攻击"></a>TLS的相关攻击</h3><h4 id="TLS读写方法（这是一个师傅尝试的"><a href="#TLS读写方法（这是一个师傅尝试的" class="headerlink" title="TLS读写方法（这是一个师傅尝试的"></a>TLS读写方法（这是一个师傅尝试的</h4><ul>
<li><p>主线程情形</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 在libc地址已经泄露的情况下对libc地址加上某个特定的偏移，利用任意地址读写直接操作TCB结构（这里我们假定libc与TLS之间的偏移是固定的）</li>
<li><input disabled="" type="checkbox"> 通过栈泄露<code>pointer_guard</code>以及<code>canary</code>(通常适用于格式化字符串攻击，根据cnitlrt师傅提供的思路，在堆题中可以将<code>__free_hook</code>劫持为<code>printf</code>函数，注意前面说过，这两组数据在栈中存在一份副本，并且Auxiliary Vector中存在指向它们的指针）)</li>
<li><input checked="" disabled="" type="checkbox"> 通过泄露libc中已经利用<code>pointer_guard</code>加密过的函数地址（如<code>_dl_fini</code>，其加密后的地址在<code>__exit_funcs</code>数组中，真实的地址可以用libc基地址计算得到），然后利用真实地址进行逆运算解出<code>pointer_guard</code></li>
<li><input disabled="" type="checkbox"> 修改<code>global_max_fast</code>然后通过free一个较大的chunk来将该chunk的地址写入到canary或者<code>pointer_guard</code>中）。</li>
</ul>
</li>
<li><p>非主线程情形：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 因为这时TCB结构体也在栈上。对于一个足够长的栈溢出，我们很容易覆盖<code>tack_guard</code>以及<code>pointer_guard</code>。注意static TLS在此种情况下是位于TCB结构体之前的，也就是说我们可以同时覆盖一些TLS变量。后面我们会给出具体的例子来介绍这种利用方式。</li>
</ul>
</li>
</ul>
<h4 id="具体攻击路径"><a href="#具体攻击路径" class="headerlink" title="具体攻击路径"></a>具体攻击路径</h4><ol>
<li>由于<code>tcache</code>是一个TLS变量，且该变量没有任何保护，可以写<code>tcache</code>来劫持整个tcache链表。</li>
<li>泄露<code>pointer_guard</code>后可以劫持exit函数的流程，可以劫持<code>__exit_funcs</code>数组来执行函数列表，但这种方法只能控制一个函数参数。</li>
<li>同样是泄露<code>pointer_guard</code>，但之后可以劫持<code>tls_dtor_list</code>（主线程情形需要任意地址写，非主线程需要任意地址写或者栈溢出），进而构造<code>dtor_list</code>结构体控制<code>rdi</code>（<code>obj</code>域）和<code>rdx</code>（<code>next</code>域），进而利用<code>setcontext+53</code>来进行SROP。 <strong>此方法适用于目前所有主流libc版本</strong> 。</li>
<li>在任意地址写情况下，如果已知一个确切的利用<code>pointer_guard</code>解密指针的位置（如<code>printf</code>函数中就存在这样的调用），可以通过修改<code>pointer_guard</code>来使解密后的函数指针指向<code>one_gadget</code>，进而getshell。</li>
<li>泄露或写入<code>stack_canary</code>来绕过<code>canary</code>机制（注意主线程的<code>stack_canary</code>和子线程的一样，并且修改主线程的<code>stack_canary</code>之后创建的子线程的<code>canary</code>也会被修改）</li>
</ol>
</div>
</article>

  </main>
  <aside>
    <p>This is an `aside`, a useful place to put information of any kind: metadata about the site author (with or without pictures), brief information about the purposes of the site, a static collection of external links or anything else.</p>
<p>For some Classless themes pictures and data about the author may suit better in the `cover` and `description` site attributes (see `config.toml`), but most of the times that kind of information will fit here better.</p>

  </aside>
  <footer role="contentinfo">
    <p>A default site footer. If you don't know what to place here maybe you should just write your name plus the current year?</p>
<p>If you want to have a sitemap, a contact form or other complex stuff, most Classless themes will also handle it nicely. Or you can take a look at the <code>aside.html</code> partial.</p>

  </footer>
</body>
